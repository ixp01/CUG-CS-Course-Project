# 基于 OpenGL 的三维图形变换与三视图生成

**课程名称：** 计算机图形学  
**实验题目：** 空间四面体的三视图程序（T7.7）  
**实验日期：** 2025年11月3日

---

## 1. 实验目的

(1) 熟悉并掌握 OpenGL (GLUT) 的基本编程环境和流程，包括窗口创建、回调函数注册以及图形绘制循环。

(2) 理解三维空间中物体的几何表示方法，学习如何使用顶点定义一个简单的三维模型（四面体）。

(3) 深入理解三维图形学中的几何变换（平移、旋转）和投影变换（正交投影）的原理及其在 OpenGL 中的实现方式。

(4) 学习并实践如何通过对模型进行一系列的几何变换，将三维物体的不同视图（主视图、俯视图、侧视图）投影并绘制在同一个二维平面上，以生成标准的三视图。

(5) 掌握矩阵堆栈机制在 OpenGL 中的应用，理解变换的独立性和状态管理。

---

## 2. 实验原理

本实验的核心是利用 OpenGL 的图形管线来生成一个三维四面体的三个基本视图（主视图、俯视图、侧视图），并将它们统一绘制在 XOZ 坐标平面上。

### (1) 三维模型定义

在三维笛卡尔坐标系中，通过定义四个顶点 **A(2, 0, 0)**、**B(2, 1, 0)**、**C(0, 1, 0)**、**D(1, 1, 1)** 的坐标来构建一个四面体。模型的线框通过连接这些顶点构成，使用 `GL_LINES` 图元进行绘制。

四面体的结构：
- **底面三角形**：A、B、C 三点在 XOY 平面（Z=0）上形成底面
- **顶点**：D 点位于 Z=1 平面上
- **六条边**：底面三角形的三条边（AB、BC、CA）+ 从顶点D到底面三个顶点的三条边（DA、DB、DC）

### (2) 视图与投影

实验采用**正交投影** (`glOrtho`)，它是一种平行投影，能够保持物体的尺寸和角度，不会产生透视收缩，非常适合工程制图中的三视图。

**视点设置**：
- 相机位置：(0, 5, 0)，位于 Y 轴正方向
- 观察点：(0, 0, 0)，坐标原点
- 上方向：(0, 0, 1)，Z 轴正方向为上

这种设置使得 **XOZ 平面**成为我们的"画纸"，所有三视图都将投影到这个平面上。

### (3) 三视图生成原理

三视图是通过对物体进行特定的几何变换，将其投影到不同的标准平面，然后再将这些投影结果变换到同一个观察平面（XOZ平面）上实现的。根据课本投影公式，平移矢量设置为 **1**。

#### 主视图 (Front View)
- **定义**：物体在 XOZ 平面上的投影
- **变换操作**：无需变换
- **原理**：由于观察视点已经设置在 Y 轴上方俯视 XOZ 平面，因此直接绘制即可得到主视图
- **颜色标识**：红色

#### 俯视图 (Top View)
- **定义**：物体在 XOY 平面上的投影
- **变换操作**：
  1. 沿 Z 轴平移 -1 个单位（平移矢量）
  2. 绕 X 轴旋转 -90°
- **原理**：通过旋转变换，将原模型的 Y 坐标映射到观察平面的 -Z 方向，实现从上往下看的效果
- **投影公式**：\[x, y, z, 1\] → \[x, 0, -(y+z₀), 1\]，其中 z₀ = 1
- **颜色标识**：绿色

#### 侧视图 (Side View)
- **定义**：物体在 YOZ 平面上的投影
- **变换操作**：
  1. 沿 X 轴平移 -1 个单位（平移矢量）
  2. 绕 Z 轴旋转 90°
- **原理**：通过旋转变换，将原模型的 Y 坐标映射到观察平面的 X 方向，实现从侧面看的效果
- **投影公式**：\[x, y, z, 1\] → \[-(y+x₀), 0, z, 1\]，其中 x₀ = 1
- **颜色标识**：蓝色

### (4) OpenGL 矩阵堆栈

为了确保每次视图变换的独立性，防止变换效果的累积，实验中广泛使用了 OpenGL 的**矩阵堆栈机制**：

- **`glPushMatrix()`**：保存当前变换矩阵状态，压入堆栈
- **`glPopMatrix()`**：恢复之前的矩阵状态，从堆栈弹出

这保证了每次变换都是基于原始的、未经变换的模型状态开始的，三个视图的变换互不干扰。

---

## 3. 实验步骤及源码

### 第一步：定义四面体模型

首先定义四面体的四个顶点坐标，这是整个实验的基础几何模型：

```cpp
// 四面体的四个顶点
float A[3] = {2.0f, 0.0f, 0.0f};  // A点
float B[3] = {2.0f, 1.0f, 0.0f};  // B点
float C[3] = {0.0f, 1.0f, 0.0f};  // C点
float D[3] = {1.0f, 1.0f, 1.0f};  // D点（顶点）
```

这四个顶点构成一个四面体：
- A、B、C 三点在 XOY 平面（Z=0）上形成底面三角形
- D 点在 Z=1 平面上，作为四面体的顶点

### 第二步：实现基本绘制函数

编写绘制四面体的函数，使用线框模式显示：

```cpp
// 绘制四面体所有边
void drawTetrahedron()
{
    glBegin(GL_LINES);
    
    // 底面三角形ABC的三条边
    glVertex3fv(A);
    glVertex3fv(B);
    
    glVertex3fv(B);
    glVertex3fv(C);
    
    glVertex3fv(C);
    glVertex3fv(A);
    
    // 从顶点D到底面三个顶点的三条边
    glVertex3fv(D);
    glVertex3fv(A);
    
    glVertex3fv(D);
    glVertex3fv(B);
    
    glVertex3fv(D);
    glVertex3fv(C);
    
    glEnd();
}
```

**关键点**：
- 使用 `GL_LINES` 图元绘制线框
- 共绘制 6 条边：底面三角形 3 条边 + 顶点到底面 3 条边

### 第三步：绘制坐标轴辅助显示

为了便于观察和理解，绘制 XOZ 平面上的坐标轴：

```cpp
void drawAxes()
{
    glLineWidth(2.0f);
    glColor3f(0.0f, 0.0f, 0.0f);  // 黑色
    
    glBegin(GL_LINES);
    
    // X轴及箭头
    glVertex3f(-3.0f, 0.0f, 0.0f);
    glVertex3f(4.0f, 0.0f, 0.0f);
    
    // Z轴及箭头
    glVertex3f(0.0f, 0.0f, -3.0f);
    glVertex3f(0.0f, 0.0f, 3.0f);
    
    glEnd();
    
    // 绘制刻度线和标签
    // ... (代码省略)
}
```

### 第四步：核心显示逻辑 - 三视图变换

这是实验的核心部分，在 `Display()` 函数中实现三视图的生成：

```cpp
void Display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    // 绘制坐标轴
    drawAxes();
    
    // 1. 主视图（正视图）- 红色
    // XOZ平面，原始位置，不需要变换
    glColor3f(1.0f, 0.0f, 0.0f);
    drawTetrahedron();
    drawText("Main View", 2.5f, 0.0f, 1.5f);
    
    // 2. 俯视图 - 绿色
    // XOY平面投影到XOZ平面
    glPushMatrix();
    glTranslatef(0.0f, 0.0f, -1.0f);       // 沿Z轴平移-1
    glRotatef(-90.0f, 1.0f, 0.0f, 0.0f);   // 绕X轴旋转-90度
    glColor3f(0.0f, 1.0f, 0.0f);
    drawTetrahedron();
    glPopMatrix();
    drawText("Top View", 2.5f, 0.0f, -2.0f);
    
    // 3. 侧视图 - 蓝色
    // YOZ平面投影到XOZ平面
    glPushMatrix();
    glTranslatef(-1.0f, 0.0f, 0.0f);       // 沿X轴平移-1
    glRotatef(90.0f, 0.0f, 0.0f, 1.0f);    // 绕Z轴旋转90度
    glColor3f(0.0f, 0.0f, 1.0f);
    drawTetrahedron();
    glPopMatrix();
    drawText("Side View", -2.8f, 0.0f, 1.5f);
    
    glutSwapBuffers();
}
```

**关键技术点说明**：

1. **矩阵堆栈管理**：`glPushMatrix()` 和 `glPopMatrix()` 保证每个视图的变换独立，不相互影响
2. **平移操作**：用于将三个视图在 XOZ 平面上分离显示，避免重叠
3. **旋转操作**：将不同平面的投影转换到统一的观察平面
4. **变换顺序**：先平移后旋转，顺序不能颠倒
5. **颜色区分**：三个视图使用不同颜色（红、绿、蓝），便于区分观察

### 第五步：设置正交投影和视点

配置正交投影，确保从 Y 轴正上方观察 XOZ 平面：

```cpp
void ChangeSize(int w, int h)
{
    if(h == 0) h = 1;
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    
    // 设置正交投影
    float aspect = (float)w / (float)h;
    if(w >= h) {
        glOrtho(-4.0 * aspect, 4.0 * aspect, -4.0, 4.0, -10.0, 10.0);
    }
    else {
        glOrtho(-4.0, 4.0, -4.0 / aspect, 4.0 / aspect, -10.0, 10.0);
    }
    
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    
    // 设置视点：从Y轴正方向向下看XOZ平面
    gluLookAt(0.0, 5.0, 0.0,    // 相机位置
              0.0, 0.0, 0.0,    // 观察点
              0.0, 0.0, 1.0);   // 上方向为Z轴
}
```

**关键点**：
- 正交投影保证了物体尺寸不会因距离而变化，符合工程制图的要求
- 视点设置使得 XOZ 平面成为观察平面
- 根据窗口宽高比调整投影范围，防止图形变形

### 第六步：初始化和主函数

```cpp
void Initial()
{
    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);  // 白色背景
    glEnable(GL_DEPTH_TEST);                // 启用深度测试
    glLineWidth(2.0f);                      // 设置线宽
}

int main(int argc, char* argv[])
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(800, 800);
    glutCreateWindow("空间四面体三视图 - T7.7");
    
    Initial();
    
    glutDisplayFunc(Display);
    glutReshapeFunc(ChangeSize);
    glutKeyboardFunc(Keyboard);
    
    glutMainLoop();
    return 0;
}
```

---

## 4. 实验结果及分析

### 运行结果

程序成功运行后，会弹出一个标题为 "空间四面体三视图 - T7.7" 的窗口。窗口背景为白色，中心绘制了黑色的 XOZ 坐标系，并显示了三个不同颜色的四面体线框视图。

**窗口显示内容**：
- 黑色 XOZ 坐标轴，带箭头和刻度
- 红色四面体线框（主视图）位于第一象限
- 绿色四面体线框（俯视图）位于 Z 轴负方向
- 蓝色四面体线框（侧视图）位于 X 轴负方向
- 各视图带有文字标签标识

### 详细分析

#### (1) 主视图（红色）

**位置**：该视图位于坐标系的第一象限（X>0, Z>0区域）

**投影原理**：主视图是四面体在 XOZ 平面上的直接投影。由于相机设置在 Y 轴正方向，观察方向垂直于 XOZ 平面，因此不需要任何变换。

**显示效果**：
- 准确展示了物体从 Y 轴正向观察时的形状
- A点和B点在X轴上重合（都在X=2位置）
- C点在X=0位置
- D点的投影显示了其在XZ平面的位置
- 符合主视图（正视图）的定义

#### (2) 俯视图（绿色）

**位置**：该视图位于 X 轴正半轴，Z 轴负半轴区域

**投影原理**：
- 俯视图是四面体在 XOY 平面上的投影
- 通过沿Z轴平移-1个单位，使其与主视图分离
- 通过绕X轴旋转-90度，将Y坐标映射到-Z'方向
- 变换后，原来在Y方向的信息被映射到Z的负方向

**显示效果**：
- 正确展示了从 Z 轴正向（上方）往下看的形状
- A、B、C、D四点在XOY平面的投影关系清晰可见
- A点和B点在Y方向上的差异（Y=0和Y=1）在变换后体现为Z方向的差异
- 符合俯视图的定义

**数学验证**：
以顶点B(2, 1, 0)为例：
- 平移后：(2, 1, -1)
- 旋转-90度后：X'=2, Y'=0, Z'=-(1+(-1))=-1
- 最终投影位置正确

#### (3) 侧视图（蓝色）

**位置**：该视图位于 X 轴负半轴，Z 轴正半轴区域

**投影原理**：
- 侧视图是四面体在 YOZ 平面上的投影
- 通过沿X轴平移-1个单位，使其与其他视图分离
- 通过绕Z轴旋转90度，将Y坐标映射到X'方向
- 变换后，原来在Y方向的信息被映射到X方向

**显示效果**：
- 正确展示了从 X 轴正向（右侧）往左看的形状
- 显示了物体在YZ方向的轮廓
- A点和B点在Y方向上的差异体现为变换后X方向的差异
- 符合侧视图（左视图）的定义

**数学验证**：
以顶点C(0, 1, 0)为例：
- 平移后：(-1, 1, 0)
- 旋转90度后：X'=-(1+(-1))=0, Y'=0, Z'=0
- 最终投影位置正确

#### (4) 变换独立性验证

通过观察可以发现，三个视图在XOZ平面上互不重叠、互不干扰，这证明了：
- `glPushMatrix()` 和 `glPopMatrix()` 的正确使用
- 每个视图的变换都是基于原始模型状态
- 矩阵堆栈机制有效地管理了变换状态

### 实验总结

本实验成功地利用 OpenGL 的几何变换功能，将一个三维物体的三个标准视图绘制在了同一个二维平面上。主要收获包括：

1. **几何变换理解**：深入理解了平移、旋转变换的作用和顺序的重要性

2. **投影变换应用**：掌握了正交投影在工程制图中的应用，理解了不同投影平面的转换方法

3. **矩阵堆栈机制**：`glPushMatrix()` 和 `glPopMatrix()` 的正确使用是保证各个视图变换独立、互不干扰的关键

4. **可视化设计**：通过为不同视图设置不同颜色和文字标签，提高了可读性和辨识度

5. **数学原理验证**：实验结果与课本中的投影公式完全一致，验证了理论的正确性

整个实验加深了对三维图形变换、投影以及 OpenGL 状态机和矩阵堆栈工作原理的理解，为后续学习更复杂的三维图形学知识打下了坚实的基础。

---

## 附录：完整源代码

（源代码已在提交的 work3.cpp 文件中）

---

**实验完成日期：** 2025年11月3日

