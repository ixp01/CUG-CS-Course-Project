# 基于 Sutherland-Hodgeman 的多边形裁剪技术实验

**学生姓名：** ___________  
**学生学号：** ___________  
**所在班级：** ___________  
**实验日期：** 2024年10月18日

---

## 一、实验目标

本次实验的主要目标包括：

1. 掌握 Sutherland-Hodgeman 裁剪算法的工作机制与设计思想
2. 理解并实现边界检测与交点求解的关键技术
3. 运用编程手段验证算法的逐步裁剪特性
4. 熟悉 OpenGL/GLUT 图形库在算法可视化中的应用
5. 提升计算机图形学领域的问题分析与解决技巧

---

## 二、理论基础

### 2.1 算法简介

Sutherland-Hodgeman 裁剪方法属于经典的多边形裁剪技术，其核心在于**将复杂的裁剪任务分解为四个独立的边界处理过程**。通过对裁剪窗口的每条边依次进行处理，最终实现对任意多边形的精确裁剪。

**处理序列：** 左侧边 → 底部边 → 右侧边 → 顶部边

### 2.2 核心原理

算法在处理多边形的每条线段时（线段由相邻顶点 P1 和 P2 构成），需根据这两个端点与当前裁剪边的空间关系，执行以下**四类操作**：

| 分类 | P1 状态 | P2 状态 | 操作说明 | 结果输出 |
|:---:|:---:|:---:|:---|:---:|
| **类型1** | 边界内 | 边界内 | 线段完全保留 | **P2** |
| **类型2** | 边界内 | 边界外 | 线段穿出边界 | **交点** |
| **类型3** | 边界外 | 边界外 | 线段完全舍弃 | **无** |
| **类型4** | 边界外 | 边界内 | 线段穿入边界 | **交点, P2** |

### 2.3 交点求解方程

对于垂直边界（左边界或右边界，$x = x_{\text{boundary}}$）：

$$
y_{\text{intersection}} = y_1 + \frac{(y_2 - y_1)(x_{\text{boundary}} - x_1)}{x_2 - x_1}
$$

对于水平边界（上边界或下边界，$y = y_{\text{boundary}}$）：

$$
x_{\text{intersection}} = x_1 + \frac{(x_2 - x_1)(y_{\text{boundary}} - y_1)}{y_2 - y_1}
$$

### 2.4 测试数据

**输入多边形的五个顶点：**
- A(4, 1)
- B(5, 4)
- C(8, 1)
- D(6, 8)
- E(1, 5)

**裁剪区域：** 矩形窗口从 (2, 2) 至 (6, 6)

**显示范围：** 坐标系从 -1 到 10，单位刻度为 1

### 2.5 算法执行流程（参考教材图6-31）

#### **阶段 0：初始状态**
- 输入：五边形顶点序列 **A, B, C, D, E**
- 状态：完整多边形，部分顶点位于裁剪窗口之外

#### **阶段 1：左边界处理（保留 x ≥ 2 的区域）**
- 执行条件：筛选满足 x ≥ 2 的部分
- 详细步骤：
  - A→B：A(4,1)与B(5,4)均在内部，保留 **B**
  - B→C：B(5,4)与C(8,1)均在内部，保留 **C**
  - C→D：C(8,1)与D(6,8)均在内部，保留 **D**
  - D→E：D(6,8)在内，E(1,5)在外，计算交点并输出
  - E→A：E(1,5)在外，A(4,1)在内，计算交点并输出 **交点, A**
- 结果：生成新的顶点序列

#### **阶段 2：底边界处理（保留 y ≥ 2 的区域）**
- 执行条件：筛选满足 y ≥ 2 的部分
- 基于阶段 1 的结果继续处理
- 详细步骤：
  - 检测每条边与 y=2 的关系
  - 顶点 A(4,1)、C(8,1) 由于 y<2 被剔除
- 结果：产生新的交点序列

#### **阶段 3：右边界处理（保留 x ≤ 6 的区域）**
- 执行条件：筛选满足 x ≤ 6 的部分
- 基于阶段 2 的结果继续处理
- 详细步骤：
  - 检测每条边与 x=6 的关系
  - x>6 的部分被裁剪
- 结果：进一步优化顶点集合

#### **阶段 4：顶边界处理（保留 y ≤ 6 的区域）**
- 执行条件：筛选满足 y ≤ 6 的部分
- 基于阶段 3 的结果继续处理
- 详细步骤：
  - 检测每条边与 y=6 的关系
  - y>6 的部分（如顶点 D(6,8)）被裁剪
- 结果：**得到最终裁剪多边形**

**标记规则：**
- 原始顶点采用字母标识：**A, B, C, D, E**
- 算法生成的交点采用数字标识：**1, 2, 3, 4...**（按生成顺序编号）
- 每个阶段的输出作为下一阶段的输入

---

## 三、算法实现与代码分析

本章节详细说明 **Sutherland-Hodgeman 算法的编程实现方案**，从底层数据组织到上层算法逻辑，逐步展现实现细节。

### 3.1 实验环境准备

- **集成开发环境：** Visual Studio 2022
- **图形渲染库：** OpenGL + GLUT
- **开发语言：** C++
- **运行平台：** Windows 10/11

**配置流程：**
1. 部署 Visual Studio 2022 开发环境
2. 获取并配置 GLUT 库文件（包括 glut32.lib、glut32.dll、glut.h）
3. 设置项目的头文件目录与库文件目录
4. 添加链接依赖：`opengl32.lib`, `glu32.lib`, `glut32.lib`

### 3.2 实现路线图

算法实现遵循以下六个步骤：

```
步骤一：定义数据结构
    ↓
步骤二：编写点位置判断函数（IsInside）
    ↓
步骤三：编写交点计算函数（GetIntersection）
    ↓
步骤四：编写单边裁剪函数（ClipByEdge）
    ↓
步骤五：编写主控算法（SutherlandHodgeman）
    ↓
步骤六：实现图形可视化（OpenGL渲染）
```

### 3.3 数据结构定义（步骤一）

设计三个基础数据类型来支撑算法运行：

```cpp
// 点的坐标结构
struct VERTEX { 
    float x, y;   // 二维坐标
    int id;       // 标识符：负值代表原始点（-1对应A），正值代表交点（1,2,3...）
};

// 矩形裁剪窗口
struct RECT_WINDOW {
    float xmin, ymin, xmax, ymax;
};

// 边界类型定义
enum BOUNDARY_TYPE {
    LEFT = 0,    // 左侧边界
    BOTTOM = 1,  // 底部边界
    RIGHT = 2,   // 右侧边界
    TOP = 3      // 顶部边界
};
```

**变量初始化：**
```cpp
RECT_WINDOW clipWindow = { 2.0f, 2.0f, 6.0f, 6.0f };  // 定义裁剪区域
vector<VERTEX> _polygon;          // 存储原始多边形
vector<VERTEX> stepResults[5];    // 保存各阶段中间结果
int nextIntersectionId = 1;       // 交点编号计数
```

### 3.4 点位置判断实现（步骤二）

**功能描述：** 判定给定点相对于指定边界的位置关系（内侧或外侧）。

**判断准则：**
- 左侧边界（LEFT）：x ≥ xmin 时点在内侧
- 底部边界（BOTTOM）：y ≥ ymin 时点在内侧
- 右侧边界（RIGHT）：x ≤ xmax 时点在内侧
- 顶部边界（TOP）：y ≤ ymax 时点在内侧

**代码实现：**
```cpp
bool IsInside(VERTEX p, int boundaryType, RECT_WINDOW window) {
    switch (boundaryType) {
    case LEFT:   return p.x >= window.xmin;
    case BOTTOM: return p.y >= window.ymin;
    case RIGHT:  return p.x <= window.xmax;
    case TOP:    return p.y <= window.ymax;
    default:     return false;
    }
}
```

### 3.5 交点计算实现（步骤三）

**功能描述：** 求解线段 P1→P2 与给定边界的交点坐标。

**计算步骤：**
1. 求线段方向向量：dx = p2.x - p1.x, dy = p2.y - p1.y
2. 根据边界类型应用对应公式：
   - **垂直边界（左/右）**：已知 x 坐标，利用比例关系求 y = p1.y + dy × (x_boundary - p1.x) / dx
   - **水平边界（上/下）**：已知 y 坐标，利用比例关系求 x = p1.x + dx × (y_boundary - p1.y) / dy
3. 为新生成的交点分配唯一编号（递增序列 1, 2, 3...）

**代码实现：**

```cpp
VERTEX GetIntersection(VERTEX p1, VERTEX p2, int boundaryType, RECT_WINDOW window) {
    VERTEX intersection;
    intersection.id = nextIntersectionId++;  // 自动编号
    float dx = p2.x - p1.x;
    float dy = p2.y - p1.y;

    switch (boundaryType) {
    case LEFT:
        intersection.x = window.xmin;
        intersection.y = p1.y + dy * (window.xmin - p1.x) / dx;
        break;
    case BOTTOM:
        intersection.y = window.ymin;
        intersection.x = p1.x + dx * (window.ymin - p1.y) / dy;
        break;
    case RIGHT:
        intersection.x = window.xmax;
        intersection.y = p1.y + dy * (window.xmax - p1.x) / dx;
        break;
    case TOP:
        intersection.y = window.ymax;
        intersection.x = p1.x + dx * (window.ymax - p1.y) / dy;
        break;
    }
    return intersection;
}
```

### 3.6 单边裁剪实现（步骤四）

**功能描述：** 对输入的多边形执行单条边界的裁剪操作，返回裁剪后的顶点列表。

**实现逻辑：**

遍历多边形的所有边（P1→P2），根据理论部分描述的四种情况输出相应顶点：

| 情况 | P1 | P2 | 输出内容 |
|:---:|:---:|:---:|:---|
| 1 | 内 | 内 | P2 |
| 2 | 内 | 外 | 交点 |
| 3 | 外 | 外 | 无输出 |
| 4 | 外 | 内 | 交点, P2 |

**代码实现：**

```cpp
vector<VERTEX> ClipByEdge(vector<VERTEX> input, int boundaryType, RECT_WINDOW window) {
    vector<VERTEX> output;
    if (input.size() == 0) return output;

    int n = input.size();
    for (int i = 0; i < n; i++) {
        VERTEX p1 = input[i];
        VERTEX p2 = input[(i + 1) % n];  // 循环取下一顶点

        bool p1Inside = IsInside(p1, boundaryType, window);
        bool p2Inside = IsInside(p2, boundaryType, window);

        if (p1Inside && p2Inside) {
            // 类型1：完全在内侧
            output.push_back(p2);
        }
        else if (p1Inside && !p2Inside) {
            // 类型2：穿出边界
            VERTEX intersection = GetIntersection(p1, p2, boundaryType, window);
            output.push_back(intersection);
        }
        else if (!p1Inside && !p2Inside) {
            // 类型3：完全在外侧，不输出
        }
        else {
            // 类型4：穿入边界
            VERTEX intersection = GetIntersection(p1, p2, boundaryType, window);
            output.push_back(intersection);
            output.push_back(p2);
        }
    }
    return output;
}
```

**实现要点：**
- 利用取模运算 `(i + 1) % n` 实现顶点的循环访问，确保首尾相连
- 四种情况的判断与处理严格遵循算法理论

### 3.7 主算法实现（步骤五）

**功能描述：** 按顺序对四条边界执行裁剪，记录每个阶段的结果。

**执行流程：**

1. 初始状态（阶段 0）：保存原始多边形
2. 依次调用 `ClipByEdge()` 处理四条边界：
   - 阶段 1: 左侧边界裁剪（x ≥ 2）
   - 阶段 2: 底部边界裁剪（y ≥ 2）
   - 阶段 3: 右侧边界裁剪（x ≤ 6）
   - 阶段 4: 顶部边界裁剪（y ≤ 6）
3. 每阶段输出作为下一阶段输入
4. 将所有阶段结果存入 `stepResults[]` 数组供可视化使用

**代码实现：**

```cpp
vector<VERTEX> SutherlandHodgeman(vector<VERTEX> polygon, RECT_WINDOW window) {
    vector<VERTEX> output = polygon;
    stepResults[0] = polygon;  // 阶段 0: 原始多边形

    output = ClipByEdge(output, LEFT, window);
    stepResults[1] = output;    // 阶段 1: 左边界裁剪

    output = ClipByEdge(output, BOTTOM, window);
    stepResults[2] = output;    // 阶段 2: 底边界裁剪

    output = ClipByEdge(output, RIGHT, window);
    stepResults[3] = output;    // 阶段 3: 右边界裁剪

    output = ClipByEdge(output, TOP, window);
    stepResults[4] = output;    // 阶段 4: 顶边界裁剪（最终结果）

    return output;
}
```

### 3.8 图形可视化实现（步骤六）

**功能描述：** 利用 OpenGL 渲染所有阶段的裁剪效果，包括坐标系统、裁剪窗口、多边形以及顶点标记。

**显示布局：**

1. **窗口组织**：采用 3×2 网格排列显示 5 个阶段
   - 第一行：阶段 0, 阶段 1, 阶段 2
   - 第二行：阶段 3, 阶段 4

2. **渲染内容**：
   - 灰色坐标轴网格（范围 0-10，刻度间隔 1）
   - 红色裁剪窗口框架
   - 彩色多边形轮廓（不同阶段用不同颜色区分）
   - 黑色顶点标记圆点
   - 顶点标签文字（字母 A-E 或数字 1,2,3...）

3. **标签绘制逻辑**：

```cpp
// 顶点标签渲染代码
for (size_t i = 0; i < stepResults[stepIndex].size(); i++) {
    char label[8];
    int vid = stepResults[stepIndex][i].id;
    
    // ID映射规则：负数映射到字母，正数为数字
    if (vid < 0) {
        sprintf_s(label, "%c", 'A' + (-vid - 1));  // -1→A, -2→B...
    } else {
        sprintf_s(label, "%d", vid);                // 1→1, 2→2...
    }
    
    // 在顶点附近渲染标签
    glRasterPos2f(stepResults[stepIndex][i].x + 0.15f, 
                  stepResults[stepIndex][i].y + 0.15f);
    for (const char* c = label; *c != '\0'; c++) {
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, *c);
    }
}
```

**配色方案：**
- 阶段 0：蓝色（初始多边形）
- 阶段 1：橙色（左边界处理）
- 阶段 2：金黄色（底边界处理）
- 阶段 3：紫色（右边界处理）
- 阶段 4：绿色（最终裁剪结果）

### 3.9 主程序结构

**执行顺序：**

1. **多边形顶点初始化**（携带ID标识）
```cpp
VERTEX p[5] = { 
    {4.0f, 1.0f, -1},  // A(4,1)
    {5.0f, 4.0f, -2},  // B(5,4)
    {8.0f, 1.0f, -3},  // C(8,1)
    {6.0f, 8.0f, -4},  // D(6,8)
    {1.0f, 5.0f, -5}   // E(1,5)
};
```

2. **调用裁剪算法**
```cpp
nextIntersectionId = 1;  // 初始化交点计数器
SutherlandHodgeman(_polygon, clipWindow);
```

3. **控制台结果输出**（用于验证和调试）

4. **启动 OpenGL 图形窗口**

### 3.10 源代码说明

完整源码参见文件 `work 2.cpp`（约393行），主要特性包括：
- ✅ 采用浮点数精度保证计算准确性
- ✅ 顶点ID追踪机制
- ✅ 双缓冲渲染技术（消除闪烁）
- ✅ 模块化函数架构
- ✅ 完整的可视化功能

---

## 四、运行结果与分析

### 4.1 程序执行效果

程序编译运行成功后，会弹出一个 **1400×900** 像素的图形窗口，分区展示五个裁剪阶段的过程。

#### 控制台信息

```
==========================================
  Sutherland-Hodgeman Polygon Clipping
==========================================
Clip Window: (2.0,2.0) to (6.0,6.0)

Step 0: 5 vertices [A, B, C, D, E]
Step 1: 6 vertices [2, A, B, C, D, 1]
Step 2: 8 vertices [3, 4, 5, B, 6, 7, 8, 9]
Step 3: 9 vertices [3, 4, 5, B, 10, 11, 12, 8, 9]
Step 4: 9 vertices [3, 4, 5, B, 10, 11, 13, 14, 9]

Original vertices: A-E (letters)
Intersection points: 1,2,3... (numbers)
All steps displayed. Press ESC to exit.
==========================================
```

### 4.2 分阶段分析

#### **阶段 0：初始多边形**
- **顶点总数：** 5
- **顶点序列：** A, B, C, D, E
- **显示特征：** 
  - 完整的五边形轮廓
  - 蓝色线条绘制
  - 部分顶点超出裁剪区域（例如 C(8,1)、D(6,8)）

#### **阶段 1：左侧边界处理（x ≥ 2）**
- **顶点总数：** 6（新增1个交点）
- **顶点序列：** 2, A, B, C, D, 1
- **处理细节：**
  - E(1,5) 因 x<2 位于左边界外侧
  - D→E 边产生交点 **1**
  - E→A 边产生交点 **2**
  - 橙色线条绘制

#### **阶段 2：底部边界处理（y ≥ 2）**
- **顶点总数：** 8（新增2个交点）
- **顶点序列：** 3, 4, 5, B, 6, 7, 8, 9
- **处理细节：**
  - A(4,1)、C(8,1) 因 y<2 位于底边界外侧
  - 生成多个交点（3, 4, 5, 6, 7, 8, 9）
  - B(5,4) 得以保留
  - 金黄色线条绘制

#### **阶段 3：右侧边界处理（x ≤ 6）**
- **顶点总数：** 9（新增1个交点）
- **顶点序列：** 3, 4, 5, B, 10, 11, 12, 8, 9
- **处理细节：**
  - C(8,1) 及相关边因 x>6 被裁剪
  - 产生交点 10, 11, 12
  - 紫色线条绘制

#### **阶段 4：顶部边界处理（y ≤ 6）**
- **顶点总数：** 9（数量不变）
- **顶点序列：** 3, 4, 5, B, 10, 11, 13, 14, 9
- **处理细节：**
  - D(6,8) 因 y>6 位于顶边界外侧
  - 产生交点 13, 14
  - **此为最终裁剪成果**
  - 绿色线条绘制
  - 裁剪后多边形完全包含在矩形区域 (2,2)-(6,6) 内

### 4.3 算法特性归纳

| 特性 | 说明 |
|:---|:---|
| **分治策略** | 将复杂问题分解为四个简单的边界处理子问题 |
| **动态顶点** | 裁剪过程可能增加顶点数量（新交点的产生） |
| **流水线处理** | 每阶段的输出直接作为下一阶段的输入 |
| **标识系统** | 通过字母与数字清晰区分原始顶点和新生成交点 |
| **数值精度** | 浮点数运算确保交点坐标的精确性 |

### 4.4 复杂度评估

- **时间开销：** O(n)，其中 n 为顶点数量
  - 每个阶段需遍历所有顶点一次
  - 四条边界总计需要 4n 次基本操作
- **空间开销：** O(n)
  - 需要额外空间存储中间阶段结果
  - 最坏情况下顶点数量可能成倍增长

### 4.5 优势与局限

#### **主要优势：**
1. ✅ **易于理解**：分治思想使算法逻辑清晰简明
2. ✅ **应用广泛**：适合处理凸多边形窗口的裁剪问题
3. ✅ **可扩展性**：算法思想可延伸至三维空间裁剪
4. ✅ **可视化友好**：分阶段展示便于教学演示和调试

#### **存在局限：**
1. ❌ **窗口限制**：仅适用于凸多边形裁剪窗口，凹窗口会产生错误结果
2. ❌ **冗余顶点**：可能生成位于同一直线上的冗余顶点
3. ❌ **精度误差**：浮点数运算存在累积误差的可能性

### 4.6 改进方向

1. **顶点优化：** 实现共线顶点的自动合并功能
2. **精度提升：** 采用双精度浮点数或有理数表示法
3. **交互增强：** 支持鼠标交互修改多边形形状和裁剪窗口
4. **动画展示：** 添加逐步动画演示裁剪全过程

---

## 五、实验总结与收获

通过本次实验，我对 Sutherland-Hodgeman 多边形裁剪算法有了深刻的认识，主要心得包括：

1. **理论联系实际**：编程实现过程加深了对算法原理的理解，特别是四种边界情况的处理策略。

2. **架构设计能力**：设计顶点ID系统（负数表示原始点，正数表示交点）简化了顶点追踪流程。

3. **可视化价值**：OpenGL 可视化使每个处理阶段的效果一目了然，极大帮助了算法验证和问题排查。

4. **数值计算意识**：在开发中遇到了整数除法导致的精度损失，改用浮点数后问题得以解决，这让我认识到数值计算精度的重要性。

5. **模块化思维**：将算法拆分成 `IsInside()`、`GetIntersection()`、`ClipByEdge()` 等独立模块，提升了代码的可维护性和可读性。

6. **调试方法**：通过控制台输出每个阶段的顶点信息，能够快速定位逻辑错误。

本实验不仅强化了我对图形裁剪算法的掌握，也提升了我的编程能力和问题分析能力，为今后学习更高级的图形算法奠定了基础。

---

## 六、参考文献

1. 《计算机图形学》教材第6章 - 多边形裁剪技术
2. OpenGL Programming Guide (Red Book)
3. Sutherland, I. E., & Hodgman, G. W. (1974). "Reentrant polygon clipping"
4. GLUT API Documentation

---

## 附录

### 附录A：源代码文件
详见：`work 2.cpp`（全文约393行）

### 附录B：运行截图
- 图1：程序主界面（1400×900像素窗口）
- 图2：阶段 0 - 初始多边形
- 图3：阶段 1 - 左边界裁剪效果
- 图4：阶段 2 - 底边界裁剪效果
- 图5：阶段 3 - 右边界裁剪效果
- 图6：阶段 4 - 最终裁剪结果

### 附录C：编译与运行指南

**环境准备：**
1. 安装 Visual Studio 2022 集成开发环境
2. 配置 OpenGL 开发环境
3. 获取 GLUT 库文件（glut32.lib, glut32.dll）
4. 项目属性配置：
   - 添加头文件搜索路径（GLUT）
   - 添加库文件搜索路径（GLUT）
   - 链接器附加依赖项：`opengl32.lib`, `glu32.lib`, `glut32.lib`

**运行方法：**
1. 使用 Visual Studio 打开 `work 2.sln` 项目文件
2. 选择 Debug/x64 编译配置
3. 按 F5 键启动调试运行
4. 观察控制台输出和图形窗口显示
5. 按 ESC 键关闭程序

---

**报告完成时间：** 2024年10月18日


